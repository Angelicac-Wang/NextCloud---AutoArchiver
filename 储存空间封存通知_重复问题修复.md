# 储存空间封存通知重复问题修复说明

## 问题描述

用户点击"幫我封存"按钮后：
1. ❌ 通知不断重复出现
2. ❌ 文件没有自动封存
3. ❌ 数据库中产生多条重复的 `archive_now` 决策记录

## 问题根本原因

### 原因 1：决策记录重复插入

**文件：** `lib/Controller/NotificationController.php` - `recordStorageDecision()` 方法

**问题：**
```php
// 旧代码只查找 storage_warning_pending 记录
$qb->select('id')
    ->from('archiver_decisions')
    ->where($qb->expr()->eq('user_id', $qb->createNamedParameter($userId)))
    ->andWhere($qb->expr()->eq('decision', $qb->createNamedParameter('storage_warning_pending')));
```

- 只更新 `storage_warning_pending` 记录
- 每次点击"幫我封存"都会插入新的 `archive_now` 记录
- 导致数据库中积累大量重复记录

**修复：**
```php
// 新代码：先删除所有旧记录，再插入新记录
$qb->delete('archiver_decisions')
    ->where($qb->expr()->eq('user_id', $qb->createNamedParameter($userId)))
    ->andWhere($qb->expr()->eq('file_path', $qb->createNamedParameter('storage_warning')));
```

### 原因 2：StorageMonitorJob 不识别 archive_now 决策

**文件：** `lib/Cron/StorageMonitorJob.php`

**问题 1：** `getUserStorageDecision()` 只查找 `skip_archive`
```php
// 旧代码
->andWhere($qb->expr()->eq('decision', $qb->createNamedParameter('skip_archive')))
```

- 不会返回 `archive_now` 决策
- 导致系统不知道用户已选择封存

**修复：**
```php
// 新代码：返回所有决策类型
->andWhere($qb->expr()->gt('decided_at', $qb->createNamedParameter(time() - 86400)))
// 不限定 decision 类型
```

**问题 2：** 主逻辑每次都发送通知

**旧逻辑：**
```php
// 总是发送通知
$this->sendStorageWarningNotification($user, $usageInfo);

// 然后检查是否 skip_archive
if ($userDecision === 'skip_archive') {
    // 跳过封存
} else {
    // 执行封存
}
```

- 即使用户已做决策，每次运行都会发送新通知
- 导致通知重复出现

**新逻辑：**
```php
if ($userDecision === 'skip_archive') {
    // 用户选择不要封存
} elseif ($userDecision === 'archive_now') {
    // 用户选择立即封存，执行封存后清除决策
    $this->archiveUntilBelowThreshold($user, $usageInfo);
    $this->clearStorageDecision($userId, 'archive_now');
} elseif ($userDecision === null || $userDecision === 'storage_warning_pending') {
    // 只有在尚未决策时才发送通知
    $this->sendStorageWarningNotification($user, $usageInfo);
}
```

## 修复内容总结

### 1. `lib/Controller/NotificationController.php`

#### 修改方法：`recordStorageDecision()`

**变更：**
- ✅ 先删除该用户所有旧的 `storage_warning` 相关决策
- ✅ 再插入新的决策记录
- ✅ 添加详细日志记录

**效果：**
- 避免重复插入决策记录
- 确保每个用户只有一条最新的决策记录

### 2. `lib/Cron/StorageMonitorJob.php`

#### 修改方法：`getUserStorageDecision()`

**变更：**
- ✅ 移除只查找 `skip_archive` 的限制
- ✅ 返回所有决策类型：`skip_archive`、`archive_now`、`storage_warning_pending`
- ✅ 添加详细日志显示决策类型

**效果：**
- 系统能够识别所有用户决策
- 可以根据不同决策执行不同操作

#### 新增方法：`clearStorageDecision()`

**功能：**
- 清除指定用户的指定决策记录
- 用于在执行完 `archive_now` 后清除决策，避免重复执行

#### 修改：主执行逻辑

**变更：**
```php
// 旧逻辑
发送通知 → 检查决策 → 决定是否封存

// 新逻辑
检查决策 → 根据决策类型：
  - skip_archive: 不封存，不发通知
  - archive_now: 立即封存，封存后清除决策
  - null/pending: 发送通知等待用户决策
```

**效果：**
- 只有在尚未决策时才发送通知（避免重复通知）
- 识别并执行 `archive_now` 决策
- 执行后自动清除决策（避免重复执行）

## 测试步骤

### 1. 清除旧数据

```bash
# 清除所有旧的决策记录和通知
docker compose exec db mysql -u nextcloud -ppassword nextcloud -e \
  "DELETE FROM oc_archiver_decisions WHERE file_path = 'storage_warning'; \
   DELETE FROM oc_notifications WHERE app = 'auto_archiver' AND object_type = 'storage';"
```

### 2. 重新启用应用

```bash
docker compose exec app php occ app:disable auto_archiver
docker compose exec app php occ app:enable auto_archiver
```

### 3. 触发存储警告

```bash
# 设置较小的配额
docker compose exec app php occ user:setting admin files quota "50 MB"

# 执行 StorageMonitorJob
docker compose exec app php occ background-job:list | Select-String "StorageMonitor"
docker compose exec app php occ background-job:execute <JOB_ID> --force-execute
```

### 4. 测试"幫我封存"按钮

1. 在 Web UI 中查看通知
2. 点击"幫我封存"按钮
3. 验证：
   - ✅ 通知消失
   - ✅ 文件被自动封存
   - ✅ 不会重复出现通知

### 5. 验证数据库

```bash
# 检查决策记录（应该为空或只有一条最新记录）
docker compose exec db mysql -u nextcloud -ppassword nextcloud -e \
  "SELECT * FROM oc_archiver_decisions WHERE file_path = 'storage_warning';"

# 检查通知（应该为空）
docker compose exec db mysql -u nextcloud -ppassword nextcloud -e \
  "SELECT * FROM oc_notifications WHERE app = 'auto_archiver' AND object_type = 'storage';"
```

## 预期行为

### 场景 1：首次超过阈值

1. StorageMonitorJob 检测到存储超过 80%
2. 没有找到用户决策
3. 发送通知给用户
4. 记录 `storage_warning_pending` 决策

### 场景 2：用户点击"幫我封存"

1. 用户点击按钮
2. 删除旧的决策记录
3. 插入新的 `archive_now` 决策
4. 删除通知
5. 触发 StorageMonitorJob
6. Job 识别 `archive_now` 决策
7. 立即执行封存
8. 封存后清除 `archive_now` 决策

### 场景 3：用户点击"不要封存"

1. 用户点击按钮
2. 删除旧的决策记录
3. 插入新的 `skip_archive` 决策
4. 删除通知
5. 下次 StorageMonitorJob 运行时
6. 识别 `skip_archive` 决策
7. 跳过自动封存，不发送通知

## 修复完成日期

2025-11-30

## 相关文件

- `my-apps/auto_archiver/lib/Controller/NotificationController.php`
- `my-apps/auto_archiver/lib/Cron/StorageMonitorJob.php`

